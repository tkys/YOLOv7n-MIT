#!/usr/bin/env python3
"""
ONNX å¤‰æ›è‡ªå‹•åŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
Phase 2 å­¦ç¿’å®Œäº† â†’ Phase 3 ONNX è‡ªå‹•å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
"""
import argparse
import subprocess
import sys
import time
from pathlib import Path
from typing import Dict, List, Optional

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’Pythonãƒ‘ã‚¹ã«è¿½åŠ 
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

class ONNXExportPipeline:
    """ONNXå¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³è‡ªå‹•åŒ–ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, checkpoint_path: Optional[str] = None, output_dir: Optional[str] = None):
        self.project_root = project_root
        self.checkpoint_path = checkpoint_path
        self.output_dir = Path(output_dir) if output_dir else self.project_root / "exports"
        self.scripts_dir = self.project_root / "scripts"
        
        # å®Ÿè¡Œãƒ­ã‚°
        self.execution_log = []
        
    def log(self, message: str, level: str = "INFO"):
        """ãƒ­ã‚°å‡ºåŠ›"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}"
        print(log_entry)
        self.execution_log.append(log_entry)
    
    def run_script(self, script_name: str, args: List[str] = None) -> Dict:
        """ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ"""
        script_path = self.scripts_dir / script_name
        
        if not script_path.exists():
            self.log(f"ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {script_path}", "ERROR")
            return {"success": False, "error": f"Script not found: {script_path}"}
        
        # ã‚³ãƒãƒ³ãƒ‰æ§‹ç¯‰
        cmd = [sys.executable, str(script_path)]
        if args:
            cmd.extend(args)
        
        self.log(f"å®Ÿè¡Œä¸­: {' '.join(cmd)}")
        
        try:
            # uvç’°å¢ƒã§ã®å®Ÿè¡Œ
            activate_script = self.project_root / "yolo-training/bin/activate"
            if activate_script.exists():
                # bash ã§ uvç’°å¢ƒã‚’activate ã—ã¦ã‹ã‚‰Pythonå®Ÿè¡Œ
                full_cmd = f"source {activate_script} && {' '.join(cmd)}"\n                
                result = subprocess.run(\n                    full_cmd,\n                    shell=True,\n                    capture_output=True,\n                    text=True,\n                    cwd=str(self.project_root)\n                )\n            else:\n                # ç›´æ¥å®Ÿè¡Œ\n                result = subprocess.run(\n                    cmd,\n                    capture_output=True,\n                    text=True,\n                    cwd=str(self.project_root)\n                )\n            \n            if result.returncode == 0:\n                self.log(f"âœ… {script_name} å®Ÿè¡ŒæˆåŠŸ")\n                return {\n                    "success": True,\n                    "stdout": result.stdout,\n                    "stderr": result.stderr,\n                    "script": script_name\n                }\n            else:\n                self.log(f"âŒ {script_name} å®Ÿè¡Œå¤±æ•— (code: {result.returncode})", "ERROR")\n                return {\n                    "success": False,\n                    "stdout": result.stdout,\n                    "stderr": result.stderr,\n                    "return_code": result.returncode,\n                    "script": script_name\n                }\n                \n        except Exception as e:\n            self.log(f"âŒ {script_name} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}", "ERROR")\n            return {"success": False, "error": str(e), "script": script_name}\n    \n    def verify_prerequisites(self) -> bool:\n        """å‰ææ¡ä»¶ç¢ºèª"""\n        self.log("=== å‰ææ¡ä»¶ç¢ºèª ===")\n        \n        # 1. å­¦ç¿’æ¸ˆã¿ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆç¢ºèª\n        checkpoint_dir = self.project_root / "runs/train"\n        \n        if self.checkpoint_path:\n            checkpoint_file = Path(self.checkpoint_path)\n            if not checkpoint_file.exists():\n                self.log(f"æŒ‡å®šã•ã‚ŒãŸãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {checkpoint_file}", "ERROR")\n                return False\n        else:\n            # æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆæ¤œç´¢\n            train_dirs = [d for d in checkpoint_dir.iterdir() if d.is_dir()]\n            if not train_dirs:\n                self.log("å­¦ç¿’çµæœãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "ERROR")\n                return False\n            \n            # GPU Fine-tuning ã‚’å„ªå…ˆ\n            gpu_dirs = [d for d in train_dirs if 'gpu' in d.name.lower()]\n            if gpu_dirs:\n                latest_dir = max(gpu_dirs, key=lambda x: x.stat().st_mtime)\n            else:\n                latest_dir = max(train_dirs, key=lambda x: x.stat().st_mtime)\n            \n            checkpoint_files = list((latest_dir / "checkpoints").glob("*.ckpt"))\n            if not checkpoint_files:\n                self.log(f"ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {latest_dir}", "ERROR")\n                return False\n            \n            self.checkpoint_path = str(max(checkpoint_files, key=lambda x: x.stat().st_mtime))\n        \n        self.log(f"âœ… ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆç¢ºèª: {self.checkpoint_path}")\n        \n        # 2. å¿…è¦ã‚¹ã‚¯ãƒªãƒ—ãƒˆç¢ºèª\n        required_scripts = [\n            "convert_to_onnx.py",\n            "benchmark_onnx.py",\n            "memory_profiler.py",\n            "cross_platform_validator.py"\n        ]\n        \n        for script in required_scripts:\n            script_path = self.scripts_dir / script\n            if not script_path.exists():\n                self.log(f"å¿…è¦ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {script}", "ERROR")\n                return False\n        \n        self.log("âœ… å¿…è¦ã‚¹ã‚¯ãƒªãƒ—ãƒˆç¢ºèªå®Œäº†")\n        \n        # 3. å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        self.log(f"âœ… å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç¢ºèª: {self.output_dir}")\n        \n        return True\n    \n    def step1_convert_to_onnx(self) -> bool:\n        """Step 1: PyTorch â†’ ONNXå¤‰æ›"""\n        self.log("\\n=== Step 1: ONNXå¤‰æ›å®Ÿè¡Œ ===")\n        \n        result = self.run_script("convert_to_onnx.py")\n        \n        if not result["success"]:\n            self.log("ONNXå¤‰æ›å¤±æ•—", "ERROR")\n            if "stderr" in result:\n                self.log(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {result['stderr']}", "ERROR")\n            return False\n        \n        # ONNX ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆç¢ºèª\n        onnx_path = self.project_root / "exports/onnx/yolov7n_mezzopiano.onnx"\n        if not onnx_path.exists():\n            self.log("ONNXãƒ•ã‚¡ã‚¤ãƒ«ãŒç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“", "ERROR")\n            return False\n        \n        file_size_mb = onnx_path.stat().st_size / 1024 / 1024\n        self.log(f"âœ… ONNXå¤‰æ›å®Œäº†: {onnx_path} ({file_size_mb:.1f}MB)")\n        \n        return True\n    \n    def step2_benchmark_performance(self) -> bool:\n        """Step 2: æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯"""\n        self.log("\\n=== Step 2: æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè¡Œ ===")\n        \n        result = self.run_script("benchmark_onnx.py")\n        \n        if not result["success"]:\n            self.log("æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å¤±æ•—", "ERROR")\n            return False\n        \n        # ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ¬ãƒãƒ¼ãƒˆç¢ºèª\n        report_path = self.project_root / "analysis/onnx_benchmark/benchmark_report.md"\n        if report_path.exists():\n            self.log(f"âœ… æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Œäº†: {report_path}")\n            return True\n        else:\n            self.log("ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ¬ãƒãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "ERROR")\n            return False\n    \n    def step3_memory_profiling(self) -> bool:\n        """Step 3: ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°"""\n        self.log("\\n=== Step 3: ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°å®Ÿè¡Œ ===")\n        \n        result = self.run_script("memory_profiler.py")\n        \n        if not result["success"]:\n            self.log("ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°å¤±æ•—", "ERROR")\n            return False\n        \n        # ãƒ¡ãƒ¢ãƒªãƒ¬ãƒãƒ¼ãƒˆç¢ºèª\n        report_path = self.project_root / "analysis/memory_profiling/memory_profile_report.md"\n        if report_path.exists():\n            self.log(f"âœ… ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°å®Œäº†: {report_path}")\n            return True\n        else:\n            self.log("ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ãƒ¬ãƒãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "ERROR")\n            return False\n    \n    def step4_cross_platform_validation(self) -> bool:\n        """Step 4: ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼"""\n        self.log("\\n=== Step 4: ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼å®Ÿè¡Œ ===")\n        \n        result = self.run_script("cross_platform_validator.py")\n        \n        if not result["success"]:\n            self.log("ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼å¤±æ•—", "ERROR")\n            return False\n        \n        # æ¤œè¨¼ãƒ¬ãƒãƒ¼ãƒˆç¢ºèª\n        report_path = self.project_root / "analysis/cross_platform/cross_platform_compatibility_report.md"\n        if report_path.exists():\n            self.log(f"âœ… ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼å®Œäº†: {report_path}")\n            return True\n        else:\n            self.log("ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼ãƒ¬ãƒãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", "ERROR")\n            return False\n    \n    def generate_summary_report(self) -> bool:\n        """ç·åˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""\n        self.log("\\n=== ç·åˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ ===")\n        \n        summary_path = self.output_dir / "onnx_export_summary.md"\n        \n        try:\n            with open(summary_path, 'w', encoding='utf-8') as f:\n                f.write("# YOLOv7n ONNX å¤‰æ›ãƒ»æœ€é©åŒ– ç·åˆãƒ¬ãƒãƒ¼ãƒˆ\\n\\n")\n                f.write(f"**ç”Ÿæˆæ—¥æ™‚**: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n")\n                f.write(f"**å…ƒãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ**: `{self.checkpoint_path}`\\n\\n")\n                \n                # å®Ÿè¡Œã‚µãƒãƒªãƒ¼\n                f.write("## ğŸš€ å®Ÿè¡Œã‚µãƒãƒªãƒ¼\\n\\n")\n                f.write("| ã‚¹ãƒ†ãƒƒãƒ— | ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ | ç”Ÿæˆç‰© |\\n")\n                f.write("|---------|-----------|--------|\\n")\n                \n                # å„ã‚¹ãƒ†ãƒƒãƒ—ã®çŠ¶æ³ç¢ºèª\n                steps = [\n                    ("ONNXå¤‰æ›", "exports/onnx/yolov7n_mezzopiano.onnx"),\n                    ("æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯", "analysis/onnx_benchmark/benchmark_report.md"),\n                    ("ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°", "analysis/memory_profiling/memory_profile_report.md"),\n                    ("ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼", "analysis/cross_platform/cross_platform_compatibility_report.md")\n                ]\n                \n                for step_name, output_file in steps:\n                    file_path = self.project_root / output_file\n                    if file_path.exists():\n                        f.write(f"| {step_name} | âœ… å®Œäº† | `{output_file}` |\\n")\n                    else:\n                        f.write(f"| {step_name} | âŒ å¤±æ•— | - |\\n")\n                \n                # ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§\n                f.write("\\n## ğŸ“ ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«\\n\\n")\n                \n                # ONNX ãƒ¢ãƒ‡ãƒ«\n                onnx_path = self.project_root / "exports/onnx/yolov7n_mezzopiano.onnx"\n                if onnx_path.exists():\n                    size_mb = onnx_path.stat().st_size / 1024 / 1024\n                    f.write(f"### ONNXãƒ¢ãƒ‡ãƒ«\\n")\n                    f.write(f"- **ãƒ•ã‚¡ã‚¤ãƒ«**: `{onnx_path.relative_to(self.project_root)}`\\n")\n                    f.write(f"- **ã‚µã‚¤ã‚º**: {size_mb:.1f}MB\\n\\n")\n                \n                # åˆ†æãƒ¬ãƒãƒ¼ãƒˆ\n                f.write("### åˆ†æãƒ¬ãƒãƒ¼ãƒˆ\\n")\n                analysis_files = [\n                    "analysis/onnx_benchmark/benchmark_report.md",\n                    "analysis/memory_profiling/memory_profile_report.md",\n                    "analysis/memory_profiling/memory_profile_visualization.png",\n                    "analysis/cross_platform/cross_platform_compatibility_report.md"\n                ]\n                \n                for analysis_file in analysis_files:\n                    file_path = self.project_root / analysis_file\n                    if file_path.exists():\n                        f.write(f"- `{analysis_file}`\\n")\n                \n                # æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—\n                f.write("\\n## ğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ— (Phase 4)\\n\\n")\n                f.write("1. **FastAPIæ¨è«–ã‚µãƒ¼ãƒãƒ¼æ§‹ç¯‰**\\n")\n                f.write("2. **DockeråŒ–å¯¾å¿œ**\\n")\n                f.write("3. **AWS Lambdaå±•é–‹æº–å‚™**\\n")\n                f.write("4. **æœ¬ç•ªç’°å¢ƒãƒ†ã‚¹ãƒˆ**\\n\\n")\n                \n                # å®Ÿè¡Œãƒ­ã‚°\n                f.write("## ğŸ“ å®Ÿè¡Œãƒ­ã‚°\\n\\n")\n                f.write("```\\n")\n                for log_entry in self.execution_log:\n                    f.write(f"{log_entry}\\n")\n                f.write("```\\n")\n            \n            self.log(f"âœ… ç·åˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†: {summary_path}")\n            return True\n            \n        except Exception as e:\n            self.log(f"ç·åˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}", "ERROR")\n            return False\n    \n    def run_full_pipeline(self) -> bool:\n        """ãƒ•ãƒ« ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ"""\n        self.log("ğŸš€ ONNXå¤‰æ›è‡ªå‹•åŒ–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³é–‹å§‹")\n        \n        start_time = time.time()\n        \n        # å‰ææ¡ä»¶ç¢ºèª\n        if not self.verify_prerequisites():\n            self.log("å‰ææ¡ä»¶ç¢ºèªå¤±æ•—", "ERROR")\n            return False\n        \n        # Step 1: ONNXå¤‰æ›\n        if not self.step1_convert_to_onnx():\n            self.log("Step 1 å¤±æ•—", "ERROR")\n            return False\n        \n        # Step 2: æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯\n        if not self.step2_benchmark_performance():\n            self.log("Step 2 å¤±æ•—", "ERROR")\n            return False\n        \n        # Step 3: ãƒ¡ãƒ¢ãƒªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°\n        if not self.step3_memory_profiling():\n            self.log("Step 3 å¤±æ•—", "ERROR")\n            return False\n        \n        # Step 4: ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æ¤œè¨¼\n        if not self.step4_cross_platform_validation():\n            self.log("Step 4 å¤±æ•—", "ERROR")\n            return False\n        \n        # ç·åˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ\n        if not self.generate_summary_report():\n            self.log("ç·åˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå¤±æ•—", "ERROR")\n            return False\n        \n        total_time = time.time() - start_time\n        \n        self.log(f"\\nğŸ‰ ONNXå¤‰æ›è‡ªå‹•åŒ–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Œäº†!")\n        self.log(f"â±ï¸ ç·å®Ÿè¡Œæ™‚é–“: {total_time:.1f}ç§’")\n        self.log(f"ğŸ“ å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.output_dir}")\n        \n        return True\n\ndef main():\n    parser = argparse.ArgumentParser(description="ONNXå¤‰æ›è‡ªå‹•åŒ–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³")\n    parser.add_argument("--checkpoint", type=str, help="ä½¿ç”¨ã™ã‚‹ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹")\n    parser.add_argument("--output-dir", type=str, help="å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª")\n    parser.add_argument("--step", type=str, choices=["convert", "benchmark", "memory", "cross-platform", "all"], \n                       default="all", help="å®Ÿè¡Œã™ã‚‹ã‚¹ãƒ†ãƒƒãƒ—")\n    \n    args = parser.parse_args()\n    \n    # ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åˆæœŸåŒ–\n    pipeline = ONNXExportPipeline(\n        checkpoint_path=args.checkpoint,\n        output_dir=args.output_dir\n    )\n    \n    # ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ\n    if args.step == "all":\n        success = pipeline.run_full_pipeline()\n    elif args.step == "convert":\n        success = pipeline.verify_prerequisites() and pipeline.step1_convert_to_onnx()\n    elif args.step == "benchmark":\n        success = pipeline.step2_benchmark_performance()\n    elif args.step == "memory":\n        success = pipeline.step3_memory_profiling()\n    elif args.step == "cross-platform":\n        success = pipeline.step4_cross_platform_validation()\n    \n    exit(0 if success else 1)\n\nif __name__ == "__main__":\n    main()