#!/usr/bin/env python3
"""
ONNX 変換自動化スクリプト
Phase 2 学習完了 → Phase 3 ONNX 自動変換パイプライン
"""
import argparse
import subprocess
import sys
import time
from pathlib import Path
from typing import Dict, List, Optional

# プロジェクトルートをPythonパスに追加
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

class ONNXExportPipeline:
    """ONNX変換パイプライン自動化クラス"""
    
    def __init__(self, checkpoint_path: Optional[str] = None, output_dir: Optional[str] = None):
        self.project_root = project_root
        self.checkpoint_path = checkpoint_path
        self.output_dir = Path(output_dir) if output_dir else self.project_root / "exports"
        self.scripts_dir = self.project_root / "scripts"
        
        # 実行ログ
        self.execution_log = []
        
    def log(self, message: str, level: str = "INFO"):
        """ログ出力"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {level}: {message}"
        print(log_entry)
        self.execution_log.append(log_entry)
    
    def run_script(self, script_name: str, args: List[str] = None) -> Dict:
        """スクリプト実行"""
        script_path = self.scripts_dir / script_name
        
        if not script_path.exists():
            self.log(f"スクリプトが見つかりません: {script_path}", "ERROR")
            return {"success": False, "error": f"Script not found: {script_path}"}
        
        # コマンド構築
        cmd = [sys.executable, str(script_path)]
        if args:
            cmd.extend(args)
        
        self.log(f"実行中: {' '.join(cmd)}")
        
        try:
            # uv環境での実行
            activate_script = self.project_root / "yolo-training/bin/activate"
            if activate_script.exists():
                # bash で uv環境をactivate してからPython実行
                full_cmd = f"source {activate_script} && {' '.join(cmd)}"\n                
                result = subprocess.run(\n                    full_cmd,\n                    shell=True,\n                    capture_output=True,\n                    text=True,\n                    cwd=str(self.project_root)\n                )\n            else:\n                # 直接実行\n                result = subprocess.run(\n                    cmd,\n                    capture_output=True,\n                    text=True,\n                    cwd=str(self.project_root)\n                )\n            \n            if result.returncode == 0:\n                self.log(f"✅ {script_name} 実行成功")\n                return {\n                    "success": True,\n                    "stdout": result.stdout,\n                    "stderr": result.stderr,\n                    "script": script_name\n                }\n            else:\n                self.log(f"❌ {script_name} 実行失敗 (code: {result.returncode})", "ERROR")\n                return {\n                    "success": False,\n                    "stdout": result.stdout,\n                    "stderr": result.stderr,\n                    "return_code": result.returncode,\n                    "script": script_name\n                }\n                \n        except Exception as e:\n            self.log(f"❌ {script_name} 実行エラー: {e}", "ERROR")\n            return {"success": False, "error": str(e), "script": script_name}\n    \n    def verify_prerequisites(self) -> bool:\n        """前提条件確認"""\n        self.log("=== 前提条件確認 ===")\n        \n        # 1. 学習済みチェックポイント確認\n        checkpoint_dir = self.project_root / "runs/train"\n        \n        if self.checkpoint_path:\n            checkpoint_file = Path(self.checkpoint_path)\n            if not checkpoint_file.exists():\n                self.log(f"指定されたチェックポイントが見つかりません: {checkpoint_file}", "ERROR")\n                return False\n        else:\n            # 最新のチェックポイント検索\n            train_dirs = [d for d in checkpoint_dir.iterdir() if d.is_dir()]\n            if not train_dirs:\n                self.log("学習結果ディレクトリが見つかりません", "ERROR")\n                return False\n            \n            # GPU Fine-tuning を優先\n            gpu_dirs = [d for d in train_dirs if 'gpu' in d.name.lower()]\n            if gpu_dirs:\n                latest_dir = max(gpu_dirs, key=lambda x: x.stat().st_mtime)\n            else:\n                latest_dir = max(train_dirs, key=lambda x: x.stat().st_mtime)\n            \n            checkpoint_files = list((latest_dir / "checkpoints").glob("*.ckpt"))\n            if not checkpoint_files:\n                self.log(f"チェックポイントファイルが見つかりません: {latest_dir}", "ERROR")\n                return False\n            \n            self.checkpoint_path = str(max(checkpoint_files, key=lambda x: x.stat().st_mtime))\n        \n        self.log(f"✅ チェックポイント確認: {self.checkpoint_path}")\n        \n        # 2. 必要スクリプト確認\n        required_scripts = [\n            "convert_to_onnx.py",\n            "benchmark_onnx.py",\n            "memory_profiler.py",\n            "cross_platform_validator.py"\n        ]\n        \n        for script in required_scripts:\n            script_path = self.scripts_dir / script\n            if not script_path.exists():\n                self.log(f"必要スクリプトが見つかりません: {script}", "ERROR")\n                return False\n        \n        self.log("✅ 必要スクリプト確認完了")\n        \n        # 3. 出力ディレクトリ作成\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        self.log(f"✅ 出力ディレクトリ確認: {self.output_dir}")\n        \n        return True\n    \n    def step1_convert_to_onnx(self) -> bool:\n        """Step 1: PyTorch → ONNX変換"""\n        self.log("\\n=== Step 1: ONNX変換実行 ===")\n        \n        result = self.run_script("convert_to_onnx.py")\n        \n        if not result["success"]:\n            self.log("ONNX変換失敗", "ERROR")\n            if "stderr" in result:\n                self.log(f"エラー詳細: {result['stderr']}", "ERROR")\n            return False\n        \n        # ONNX ファイル生成確認\n        onnx_path = self.project_root / "exports/onnx/yolov7n_mezzopiano.onnx"\n        if not onnx_path.exists():\n            self.log("ONNXファイルが生成されていません", "ERROR")\n            return False\n        \n        file_size_mb = onnx_path.stat().st_size / 1024 / 1024\n        self.log(f"✅ ONNX変換完了: {onnx_path} ({file_size_mb:.1f}MB)")\n        \n        return True\n    \n    def step2_benchmark_performance(self) -> bool:\n        """Step 2: 性能ベンチマーク"""\n        self.log("\\n=== Step 2: 性能ベンチマーク実行 ===")\n        \n        result = self.run_script("benchmark_onnx.py")\n        \n        if not result["success"]:\n            self.log("性能ベンチマーク失敗", "ERROR")\n            return False\n        \n        # ベンチマークレポート確認\n        report_path = self.project_root / "analysis/onnx_benchmark/benchmark_report.md"\n        if report_path.exists():\n            self.log(f"✅ 性能ベンチマーク完了: {report_path}")\n            return True\n        else:\n            self.log("ベンチマークレポートが見つかりません", "ERROR")\n            return False\n    \n    def step3_memory_profiling(self) -> bool:\n        """Step 3: メモリプロファイリング"""\n        self.log("\\n=== Step 3: メモリプロファイリング実行 ===")\n        \n        result = self.run_script("memory_profiler.py")\n        \n        if not result["success"]:\n            self.log("メモリプロファイリング失敗", "ERROR")\n            return False\n        \n        # メモリレポート確認\n        report_path = self.project_root / "analysis/memory_profiling/memory_profile_report.md"\n        if report_path.exists():\n            self.log(f"✅ メモリプロファイリング完了: {report_path}")\n            return True\n        else:\n            self.log("メモリプロファイリングレポートが見つかりません", "ERROR")\n            return False\n    \n    def step4_cross_platform_validation(self) -> bool:\n        """Step 4: クロスプラットフォーム検証"""\n        self.log("\\n=== Step 4: クロスプラットフォーム検証実行 ===")\n        \n        result = self.run_script("cross_platform_validator.py")\n        \n        if not result["success"]:\n            self.log("クロスプラットフォーム検証失敗", "ERROR")\n            return False\n        \n        # 検証レポート確認\n        report_path = self.project_root / "analysis/cross_platform/cross_platform_compatibility_report.md"\n        if report_path.exists():\n            self.log(f"✅ クロスプラットフォーム検証完了: {report_path}")\n            return True\n        else:\n            self.log("クロスプラットフォーム検証レポートが見つかりません", "ERROR")\n            return False\n    \n    def generate_summary_report(self) -> bool:\n        """総合レポート生成"""\n        self.log("\\n=== 総合レポート生成 ===")\n        \n        summary_path = self.output_dir / "onnx_export_summary.md"\n        \n        try:\n            with open(summary_path, 'w', encoding='utf-8') as f:\n                f.write("# YOLOv7n ONNX 変換・最適化 総合レポート\\n\\n")\n                f.write(f"**生成日時**: {time.strftime('%Y-%m-%d %H:%M:%S')}\\n")\n                f.write(f"**元チェックポイント**: `{self.checkpoint_path}`\\n\\n")\n                \n                # 実行サマリー\n                f.write("## 🚀 実行サマリー\\n\\n")\n                f.write("| ステップ | ステータス | 生成物 |\\n")\n                f.write("|---------|-----------|--------|\\n")\n                \n                # 各ステップの状況確認\n                steps = [\n                    ("ONNX変換", "exports/onnx/yolov7n_mezzopiano.onnx"),\n                    ("性能ベンチマーク", "analysis/onnx_benchmark/benchmark_report.md"),\n                    ("メモリプロファイリング", "analysis/memory_profiling/memory_profile_report.md"),\n                    ("クロスプラットフォーム検証", "analysis/cross_platform/cross_platform_compatibility_report.md")\n                ]\n                \n                for step_name, output_file in steps:\n                    file_path = self.project_root / output_file\n                    if file_path.exists():\n                        f.write(f"| {step_name} | ✅ 完了 | `{output_file}` |\\n")\n                    else:\n                        f.write(f"| {step_name} | ❌ 失敗 | - |\\n")\n                \n                # 生成ファイル一覧\n                f.write("\\n## 📁 生成ファイル\\n\\n")\n                \n                # ONNX モデル\n                onnx_path = self.project_root / "exports/onnx/yolov7n_mezzopiano.onnx"\n                if onnx_path.exists():\n                    size_mb = onnx_path.stat().st_size / 1024 / 1024\n                    f.write(f"### ONNXモデル\\n")\n                    f.write(f"- **ファイル**: `{onnx_path.relative_to(self.project_root)}`\\n")\n                    f.write(f"- **サイズ**: {size_mb:.1f}MB\\n\\n")\n                \n                # 分析レポート\n                f.write("### 分析レポート\\n")\n                analysis_files = [\n                    "analysis/onnx_benchmark/benchmark_report.md",\n                    "analysis/memory_profiling/memory_profile_report.md",\n                    "analysis/memory_profiling/memory_profile_visualization.png",\n                    "analysis/cross_platform/cross_platform_compatibility_report.md"\n                ]\n                \n                for analysis_file in analysis_files:\n                    file_path = self.project_root / analysis_file\n                    if file_path.exists():\n                        f.write(f"- `{analysis_file}`\\n")\n                \n                # 次のステップ\n                f.write("\\n## 🎯 次のステップ (Phase 4)\\n\\n")\n                f.write("1. **FastAPI推論サーバー構築**\\n")\n                f.write("2. **Docker化対応**\\n")\n                f.write("3. **AWS Lambda展開準備**\\n")\n                f.write("4. **本番環境テスト**\\n\\n")\n                \n                # 実行ログ\n                f.write("## 📝 実行ログ\\n\\n")\n                f.write("```\\n")\n                for log_entry in self.execution_log:\n                    f.write(f"{log_entry}\\n")\n                f.write("```\\n")\n            \n            self.log(f"✅ 総合レポート生成完了: {summary_path}")\n            return True\n            \n        except Exception as e:\n            self.log(f"総合レポート生成エラー: {e}", "ERROR")\n            return False\n    \n    def run_full_pipeline(self) -> bool:\n        """フル パイプライン実行"""\n        self.log("🚀 ONNX変換自動化パイプライン開始")\n        \n        start_time = time.time()\n        \n        # 前提条件確認\n        if not self.verify_prerequisites():\n            self.log("前提条件確認失敗", "ERROR")\n            return False\n        \n        # Step 1: ONNX変換\n        if not self.step1_convert_to_onnx():\n            self.log("Step 1 失敗", "ERROR")\n            return False\n        \n        # Step 2: 性能ベンチマーク\n        if not self.step2_benchmark_performance():\n            self.log("Step 2 失敗", "ERROR")\n            return False\n        \n        # Step 3: メモリプロファイリング\n        if not self.step3_memory_profiling():\n            self.log("Step 3 失敗", "ERROR")\n            return False\n        \n        # Step 4: クロスプラットフォーム検証\n        if not self.step4_cross_platform_validation():\n            self.log("Step 4 失敗", "ERROR")\n            return False\n        \n        # 総合レポート生成\n        if not self.generate_summary_report():\n            self.log("総合レポート生成失敗", "ERROR")\n            return False\n        \n        total_time = time.time() - start_time\n        \n        self.log(f"\\n🎉 ONNX変換自動化パイプライン完了!")\n        self.log(f"⏱️ 総実行時間: {total_time:.1f}秒")\n        self.log(f"📁 出力ディレクトリ: {self.output_dir}")\n        \n        return True\n\ndef main():\n    parser = argparse.ArgumentParser(description="ONNX変換自動化パイプライン")\n    parser.add_argument("--checkpoint", type=str, help="使用するチェックポイントファイルパス")\n    parser.add_argument("--output-dir", type=str, help="出力ディレクトリ")\n    parser.add_argument("--step", type=str, choices=["convert", "benchmark", "memory", "cross-platform", "all"], \n                       default="all", help="実行するステップ")\n    \n    args = parser.parse_args()\n    \n    # パイプライン初期化\n    pipeline = ONNXExportPipeline(\n        checkpoint_path=args.checkpoint,\n        output_dir=args.output_dir\n    )\n    \n    # ステップ実行\n    if args.step == "all":\n        success = pipeline.run_full_pipeline()\n    elif args.step == "convert":\n        success = pipeline.verify_prerequisites() and pipeline.step1_convert_to_onnx()\n    elif args.step == "benchmark":\n        success = pipeline.step2_benchmark_performance()\n    elif args.step == "memory":\n        success = pipeline.step3_memory_profiling()\n    elif args.step == "cross-platform":\n        success = pipeline.step4_cross_platform_validation()\n    \n    exit(0 if success else 1)\n\nif __name__ == "__main__":\n    main()